import enum
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtSvg import *
from PyQt5.QtWidgets import *
import sys
import card_lib

class TableScene(QGraphicsScene):
    """ A scene with a table cloth background """
    def __init__(self):
        super().__init__()
        self.tile = QPixmap('cards/table.png')
        self.setBackgroundBrush(QBrush(self.tile))

class CardItem(QGraphicsSvgItem):
    """ A simple overloaded QGraphicsSvgItem that also stores the card position """
    def __init__(self, renderer, position):
        super().__init__()
        self.setSharedRenderer(renderer)
        self.position = position


class CardView(QGraphicsView):
    """ A View widget that represents the table area displaying a players cards. """

    # Underscores indicate a private function/method!
    def __read_cards(): # Ignore the PyCharm warning on this line. It's correct.
        """
        Reads all the 52 cards from files.
        :return: Dictionary of SVG renderers
        """
        all_cards = dict() # Dictionaries let us have convenient mappings between cards and their images
        for suit_file, suit in zip('CDHS', range(1,5)): # Check the order of the suits here!!! //HDSC org
            for value_file, value in zip(['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'], range(2, 15)):
                file = value_file + suit_file
                key = (value, suit)  # I'm choosing this tuple to be the key for this dictionary
                all_cards[key] = QSvgRenderer('cards/' + file + '.svg')
        return all_cards

    # We read all the card graphics as static class variables
    back_card = QSvgRenderer('cards/Red_Back_2.svg')
    all_cards = __read_cards()

    def __init__(self, cards_model, card_spacing=250, padding=10):
        """
        Initializes the view to display the content of the given model
        :param cards_model: A model that represents a set of cards.
        The model should have: data_changed, cards, clicked_position, flipped,
        :param card_spacing: Spacing between the visualized cards.
        :param padding: Padding of table area around the visualized cards.
        """
        self.scene = TableScene()
        super().__init__(self.scene)

        self.model = cards_model
        self.card_spacing = card_spacing
        self.padding = padding

        # Whenever the this window should update, it should call the "change_cards" method.
        # This can, for example, be done by connecting it to a signal.
        # The view can listen to changes:
        cards_model.data_changed.connect(self.change_cards)
        cards_model.data_changed.connect(self.change_cards)
        # It is completely optional if you want to do it this way, or have some overreaching Player/GameState
        # call the "change_cards" method instead. z

        # Add the cards the first time around to represent the initial state.
        self.change_cards()

    def change_cards(self):
        # Add the cards from scratch
        self.scene.clear()
        for i, card in enumerate(self.model.hand):
            # The ID of the card in the dictionary of images is a tuple with (value, suit), both integers
            graphics_key = (card.value, card.suit)
            renderer = self.back_card if self.model.flipped(i) else self.all_cards[graphics_key]
            c = CardItem(renderer, i)

            # Shadow effects are cool!
            shadow = QGraphicsDropShadowEffect(c)
            shadow.setBlurRadius(10.)
            shadow.setOffset(5, 5)
            shadow.setColor(QColor(0, 0, 0, 180)) # Semi-transparent black!
            c.setGraphicsEffect(shadow)

            # Place the cards on the default positions
            c.setPos(c.position * self.card_spacing, 0)
            self.scene.addItem(c)

        self.update_view()

    def update_view(self):
        scale = (self.viewport().height()-2*self.padding)/313
        self.resetTransform()
        self.scale(scale, scale)
        # Put the scene bounding box
        self.setSceneRect(-self.padding//scale, -self.padding//scale,
                          self.viewport().width()//scale, self.viewport().height()//scale)

    def resizeEvent(self, painter):
        # This method is called when the window is resized.
        # If the widget is resize, we gotta adjust the card sizes.
        # QGraphicsView automatically re-paints everything when we modify the scene.
        self.update_view()
        super().resizeEvent(painter)

    # This is the Controller part of the GUI, handling input events that modify the Model
    def mousePressEvent(self, event):
        # We can check which item, if any, that we clicked on by fetching the scene items (neat!)
        pos = self.mapToScene(event.pos())
        item = self.scene.itemAt(pos, self.transform())
        if item is not None:
            # Report back that the user clicked on the card at given position:
            # The model can choose to do whatever it wants with this information.
            self.model.clicked_position(item.position)

class GameState(QObject):
    data_changed = pyqtSignal()

    def __init__(self):

                #creates the deck and hands required for the game, and draws the appropriate amount of cards

        QObject.__init__(self)
        self.pot = 0

        self.deck = card_lib.Deck()
        self.deck.shuffle()

        self.player1 = HandModel()
        self.player1.draw(2, self.deck)

        self.player2 = HandModel()
        self.player2.draw(2, self.deck)

        self.board = HandModel()
        self.board.draw(3, self.deck)
        self.board.flip()

        self.active_player = self.player1
        self.inactive_player = self.player2
        self.active_player.flip()

        self.player1.data_changed.emit()
        self.player2.data_changed.emit()
        self.data_changed.emit()

    def raise_bet(self):

        #raises the bet for the active player, warns the player if trying to place a bet when out of money

        if self.active_player.credits < 10:
            self.warn = QLabel('Not enough money to place bet')
            self.warn.setGeometry(QRect(50, 50, 300, 40))
            self.warn.show()
            return
        self.active_player.credits -= 10
        self.active_player.bet += 10
        self.pot += 10
        self.active_player.data_changed.emit()
        self.data_changed.emit()

    def fold(self):

        #makes the game skip directly to comparing the hands

        self.check_winner()
        self.player1.data_changed.emit()
        self.player2.data_changed.emit()
        self.data_changed.emit()

    def call(self):

        #switches active player and warns the player if trying to call without having matched the opponents bet

        if self.active_player.bet < self.inactive_player.bet:
            self.warn = QLabel('Need to at least match opponents bet')
            self.warn.setGeometry(QRect(50, 50, 300, 40))
            self.warn.show()
            return
        self.player1.flip()
        self.player2.flip()

        if self.active_player == self.player2:
            self.next_turn()
        else:
            self.active_player = self.player2
            self.inactive_player = self.player1

        self.player1.data_changed.emit()
        self.player2.data_changed.emit()
        self.data_changed.emit()

    def next_turn(self):

        #draws a card from the deck for the board as long as there are not five cards on the board,
        # in that case goes to comparing hands instead

        if len(self.board.hand) > 4:
            self.check_winner()
            return
        self.active_player = self.player1
        self.inactive_player = self.player2
        self.board.draw(1, self.deck)
        self.board.data_changed.emit()
        self.player1.data_changed.emit()
        self.player2.data_changed.emit()
        self.data_changed.emit()


    def check_winner(self):

        #compares hands and shows a prompt with the winning player,
        # also shows if the match is complete (based on if any player is broke)

        self.player1.best_poker_hand(self.board.hand)
        self.player2.best_poker_hand(self.board.hand)

        self.won = QLabel()
        self.won.setGeometry(QRect(40, 40, 160, 40))

        if self.player1.best_hand < self.player2.best_hand:
            self.won.setText('Player 2 Won')
            self.winner = self.player2

        elif self.player2.best_hand < self.player1.best_hand:
            self.won.setText('Player 1 Won')
            self.winner = self.player1

        elif self.player1.hand < self.player2.hand:
            self.won.setText('Player 1 Won')
            self.winner = self.player1

        elif self.player2.hand < self.player1.hand:
            self.won.setText('Player 2 Won')
            self.winner = self.player2

        else:
            self.won.setText('Draw')
            self.won.show()
            return

        self.winner.credits = self.winner.credits + self.pot
        self.won.show()
        self.clear()
        if self.player1.credits < 10:
            self.warn = QLabel('Match complete, player 2 won')
            self.warn.setGeometry(QRect(50, 50, 300, 40))
            self.warn.show()
            return
        elif self.player2.credits < 10:
            self.warn = QLabel('Match complete, player 1 won')
            self.warn.setGeometry(QRect(50, 50, 300, 40))
            self.warn.show()
            return
        else:
            self.new_game()


    def clear(self):

        #clears board and hands from cards, as well as pot and bet values

        self.player1.hand = []
        self.player2.hand = []
        self.player1.bet = 0
        self.player2.bet = 0
        self.board.hand = []
        self.pot = 0
        self.active_player = self.player1
        self.inactive_player = self.player2
        self.active_player.flipped_cards = False
        self.inactive_player.flipped_cards = True

        self.player1.data_changed.emit()
        self.player2.data_changed.emit()
        self.board.data_changed.emit()
        self.data_changed.emit()

    def new_game(self):

        #draws cards for a new game

        self.deck.shuffle()
        self.active_player.draw(2,self.deck)
        self.inactive_player.draw(2,self.deck)
        self.board.draw(3,self.deck)

        self.player1.data_changed.emit()
        self.player2.data_changed.emit()
        self.board.data_changed.emit()
        self.data_changed.emit()

class HandModel(card_lib.Hand, QObject):
    data_changed = pyqtSignal()

    def __init__(self):
        card_lib.Hand.__init__(self)
        QObject.__init__(self)
        self.credits = 100
        self.flipped_cards = True
        self.bet = 0
        self.hand = []


    def flip(self):
        # Flips over the cards (to hide them)
        self.flipped_cards = not self.flipped_cards
        self.data_changed.emit()

    def flipped(self, i):
        # This model only flips all or no cards, so we don't care about the index.
        # Might be different for other games though!
        return self.flipped_cards

    def clicked_position(self, i):
        # Mark the card as position "i" to be thrown away
       # self.marked_cards[i] = not self.marked_cards[i]
        self.data_changed.emit()


class Buttons(QWidget):
    data_changed = pyqtSignal()

    #class containing the buttons for raising, folding and calling, also connects them to the appropriate method in the GameState class

    def __init__(self, state):
        super().__init__()
        self.RaiseButton = QPushButton("Raise 10€")
        self.CallButton = QPushButton("Call")
        self.FoldButton = QPushButton("Fold")
        self.RaiseButton.clicked.connect(state.raise_bet)
        self.CallButton.clicked.connect(state.call)
        self.FoldButton.clicked.connect(state.fold)


class Labels(QWidget):
    data_changed = pyqtSignal()

    #contains the labels, as well as a method for updating them (called upon whenever the gamestate changes)

    def __init__(self,state):
        super().__init__()
        self.state_model = state
        self.state_model.data_changed.connect(self.update_labels)
        self.min_bet_label = QLabel()
        self.pot_label = QLabel()
        self.bet_label = QLabel()
        self.credits_label = QLabel()
        self.update_labels()

    def update_labels(self):
        self.min_bet_label.setText('Minumum bet:' + str(self.state_model.inactive_player.bet))
        self.credits_label.setText('Credits:' + str(self.state_model.active_player.credits))
        self.pot_label.setText('Current Pot:' + str(self.state_model.pot))
        self.bet_label.setText('Currently Betted:' + str(self.state_model.active_player.bet))



def main():
    app = QApplication(sys.argv)

    game = GameState()
    board_view = CardView(game.board)
    player1_view = CardView(game.active_player)
    player2_view = CardView(game.inactive_player)

    buttons = Buttons(game)
    labels = Labels(game)

    box = QVBoxLayout()
    box.addWidget(player1_view)
    box.addWidget(board_view)
    box.addWidget(player2_view)

    box.addWidget(buttons.RaiseButton)
    box.addWidget(buttons.CallButton)
    box.addWidget(buttons.FoldButton)

    box.addWidget(labels.min_bet_label)
    box.addWidget(labels.pot_label)
    box.addWidget(labels.bet_label)
    box.addWidget(labels.credits_label)

    game_view = QGroupBox('Game')
    game_view.setLayout(box)
    game_view.show()

    sys.exit(app.exec_())


if __name__ == '__main__':
    main()
